    Emitter types:
-Observable - стандартный тип наблюдаемого потока данных
-Flowable - то же observable, но с поддержкой backpressure
-Maybe - если излучает значение - вызывает только onSuccess, иначе - только onComplete
-Single - используется когда мы хотим получить единственное значение. При его излучении будет вызван onSuccess, при отсутствии значения - onError
-Completable - не возвращает данных, а только говорит о том была ли успешно завершена операция через onComplete
--------------------------------------------------------------------------------------------------------------------------------------------------
    Schedulers:
subscribeOn и observeOn позволяют указывать, какие потоки следует использовать.
subscribeOn указывает, в каком потоке будет выполняться emitter; observeOn указывает, в каком потоке следует получать значения.
В качестве параметра передаётся Scheduler (планировщик), управляющий потоками.
Виды планировщиков:
-Scheduler.io() - наиболее часто используемый вид планировщика, предназначенный для асинхронного ввода/вывода.
-Scheduler.computation() - используется для тяжёлых вычислений, количество потоков ограничено тех. хар-ками устройства (физ. потоки).
-Scheduler.newThread() - создаёт новый поток для текущего эмиттера, следует использовать с осторожностью, т.к. большое число потоков может вызвать нестабильность;
также, мы можем указать сколько именно параллельных потоков мы хотим запустить одновременно: .subscribeOn(Schedulers.newThread(), 8).
-Scheduler.single() - независимо от количества эмиттеров будет работать в единственном потоке; можно рассматривать как main thread.
-Scheduler.trampoline() - будет выполнятся в текущем потоке, смотря откуда был вызван; используется для блокирующих операций.

    Executor Scheduler:
Настраиваемый IO Scheduler, где мы можем указать фиксированное количество потоков. Используется в случае большого кол-ва io операций:
val executor = Executors.newFixedThreadPool(10)
val pooledScheduler = Schedulers.from(executor)

    AndroidSchedulers.mainThread:
Вызванный в observeOn вернёт поток данных в UI Thread.
--------------------------------------------------------------------------------------------------------------------------------------------------
    Transformers:
Трансформеры преобразовывают поток данных эмиттера с помощью .compose(...).
Например, используем transform для перенаправления потоков:

    Observable.just("1", "2", "3")
        .compose(applyObservableAsync())
        .subscribe { v -> println("The First Observable Received: $v") }

    Observable.just("4", "5", "6")
        .compose(applyObservableAsync())
        .subscribe { v -> println("The Second Observable Received: $v") }

    ....

    fun <T> applyObservableAsync(): ObservableTransformer<T, T> {
        return ObservableTransformer { observable ->
            observable
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
        }
    }
--------------------------------------------------------------------------------------------------------------------------------------------------
    Operators:
-map() - преобразовывает каждый элемент из потока данных эмиттера:

Observable.just("1", "2", "3")
    .map { m -> m + " map" }
    .subscribe { v -> println("Received: $v") }
------------------------------------------
-flatMap() - преобразовывает каждый элемент потока к отдельному эмиттеру:

Observable.just("1", "2", "3")
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .flatMap { m ->
        Observable.just(m + " flat map")
            .subscribeOn(Schedulers.io())
    }
    .subscribe { v -> println("Received: $v") }
------------------------------------------
-zip() - объединяет значения нескольких эмиттеров с помощью определённой функции:

Observable.zip(
    Observable.just(
        "1", "2", "3", "4", "5", "6"),
    Observable.just(
        "One", "Two", "Three", "Four", "Five"),
    BiFunction<String, String, String> { num, text ->
        "$num is $text"
    }
)
    .subscribe { v -> println("Received: $v") }
------------------------------------------
-concat() и merge() предназначены для объединения значений эмиттеров.
concat() будет излучать значения эмиттеров последовательно, merge() же будет излучать значения одновременно.
------------------------------------------
-filter() фильтрует излучаемые значения по заданному условию.
------------------------------------------
-repeat() повторит излучение всех значений заданное кол-во раз.
------------------------------------------
-take() выведет только n первых полученных значений.
--------------------------------------------------------------------------------------------------------------------------------------------------
    Disposable:
Disposable освободит ресурсы, память и потоки, используемые эмиттером. Следует использовать с осторожностью, т.к. возможно удаление наблюдаемых значений до их использования.
Альтернативой является CompositeDisposable, в который мы добавляем используемые эмиттеры, и связываем их очищения с жизненным циклом (напр. onDestroy).
Пример в intervalTest()

